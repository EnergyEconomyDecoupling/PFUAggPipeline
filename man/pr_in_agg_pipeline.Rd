% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PrIn_aggregations.R
\name{pr_in_agg_pipeline}
\alias{pr_in_agg_pipeline}
\title{Bundle several aggregation calculations together}
\usage{
pr_in_agg_pipeline(
  .psut_data,
  product_agg_map,
  industry_agg_map,
  p_industries,
  do_chops = FALSE,
  pattern_type = "exact",
  piece = "noun",
  bracket_notation = RCLabels::bracket_notation,
  arrow_notation = RCLabels::arrow_notation,
  prepositions = RCLabels::prepositions_list,
  method = "SVD",
  tol_invert = .Machine$double.eps,
  product_type = Recca::row_col_types$product_type,
  industry_type = Recca::row_col_types$industry_type,
  R = Recca::psut_cols$R,
  U = Recca::psut_cols$U,
  V = Recca::psut_cols$V,
  Y = Recca::psut_cols$Y,
  r_eiou = Recca::psut_cols$r_eiou,
  U_eiou = Recca::psut_cols$U_eiou,
  U_feed = Recca::psut_cols$U_feed,
  S_units = Recca::psut_cols$S_units,
  .prime = "_prime",
  country = Recca::psut_cols$country,
  year = Recca::psut_cols$year,
  R_aggregated_colname = paste0(R, aggregated_suffix),
  U_aggregated_colname = paste0(U, aggregated_suffix),
  U_feed_aggregated_colname = paste0(U_feed, aggregated_suffix),
  U_eiou_aggregated_colname = paste0(U_eiou, aggregated_suffix),
  r_eiou_aggregated_colname = paste0(r_eiou, aggregated_suffix),
  V_aggregated_colname = paste0(V, aggregated_suffix),
  Y_aggregated_colname = paste0(Y, aggregated_suffix),
  S_units_aggregated_colname = paste0(S_units, aggregated_suffix),
  aggregated_suffix = Recca::aggregate_cols$aggregated_suffix,
  product_aggregation = PFUAggDatabase::aggregation_df_cols$product_aggregation,
  industry_aggregation = PFUAggDatabase::aggregation_df_cols$industry_aggregation,
  specified = PFUAggDatabase::aggregation_df_cols$specified,
  despecified = PFUAggDatabase::aggregation_df_cols$despecified,
  grouped = PFUAggDatabase::aggregation_df_cols$grouped,
  chopped_mat = PFUAggDatabase::aggregation_df_cols$chopped_mat,
  chopped_var = PFUAggDatabase::aggregation_df_cols$chopped_var,
  Y_matname = Recca::psut_cols$Y,
  R_matname = Recca::psut_cols$R,
  product_sector = PFUAggDatabase::aggregation_df_cols$product_sector,
  none = PFUAggDatabase::agg_metadata$none
)
}
\arguments{
\item{.psut_data}{PSUT matrices in wide-by-matrix format.
This could be an entire data frame,
a slice (row) of the data frame, or
a group of the data frame.}

\item{product_agg_map}{The product aggregation map.}

\item{industry_agg_map}{The industry aggregation map.}

\item{p_industries}{A string vector of primary industries.}

\item{do_chops}{A boolean that tells whether to do the chopping of \strong{R} and \strong{Y} matrices.}

\item{pattern_type}{The matching type for row and column labels.
Default is "exact".}

\item{piece}{The piece of row and column labels to be matched.
Default is "noun".}

\item{bracket_notation}{A row and column notation.
Default is \code{RCLabels::bracket_notation}.}

\item{arrow_notation}{A row and column notation.
Default is \code{RCLabels::arrow_notation}.}

\item{prepositions}{Prepositions to be used in row and column labels.
Default is \code{RCLabels::prepositions_list}.}

\item{method}{The method for doing matrix inversion when chopping the \strong{R} and \strong{Y} matrices.
Default is "SVD" for singular value decomposition.}

\item{tol_invert}{The tolerance for nearness to 0 in matrix inversion.
Default is \code{.Machine$double.eps}.}

\item{product_type, industry_type}{See \code{Recca::row_col_types}.}

\item{R, U, U_feed, U_eiou, r_eiou, V, Y, S_units, country, year}{The names of input columns in \code{.psut_data}.
Default values are from \code{Recca::psut_cols}.}

\item{.prime}{The suffix for the columns containing chopped ECC matrices.
Default is "_prime".}

\item{R_aggregated_colname, U_aggregated_colname, V_aggregated_colname, Y_aggregated_colname, r_eiou_aggregated_colname, U_eiou_aggregated_colname, U_feed_aggregated_colname, S_units_aggregated_colname}{The names of output aggregated columns.
Defaults are the matrix names with \code{aggregated_suffix} appended.}

\item{aggregated_suffix}{The suffix for aggregated column names.
See \code{Recca::aggregate_cols}.}

\item{product_aggregation, industry_aggregation, specified, despecified, grouped, product_sector}{See \code{PFUAggDatabase::aggregation_df_cols}.}

\item{chopped_mat, chopped_var}{Column names that indicate which matrix has been chopped, \strong{R} or \strong{Y}.
Default values are from \code{PFUAggDatabase::aggregation_df_cols}.}

\item{Y_matname, R_matname}{Matrix names for the \code{chopped_mat} and \code{chopped_var} columns.
Default values are from \code{Recca::psut_cols$R} and \code{Recca::psut_cols$Y}.}

\item{none}{The string to specify no aggregations.
Default is \code{PFUAggDatabase::agg_metadata$none}.}
}
\value{
A data frame of efficiencies for the original, despecified, and grouped versions
of \code{.psut_data}.
}
\description{
The efficiency pipeline calculates efficiencies
for various despecifications, row aggregations, and column aggregations.
}
\details{
This function is an attempt to streamline the calculation pipeline
by eliminating the need to repeatedly re-load intermediate targets from disk.
It bundles the work of previous targets to
\itemize{
\item despecify and aggregate both product and industry dimensions of PSUT matrices,
\item group and aggregate products,
\item group and aggregate industries,
\item group and aggregate both products and industries,
\item calculate primary-to-final efficiencies,
\item calculate primary-to-useful efficiencies, and
\item calculate final-to-useful efficiencies.
}
}
